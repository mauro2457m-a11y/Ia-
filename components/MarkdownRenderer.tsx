import React from 'react';

interface MarkdownRendererProps {
  content: string;
}

export const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content }) => {
  // Safe, lightweight custom parser for the specific subset of Markdown generated by the AI
  const renderContent = (text: string) => {
    if (!text) return null;

    const lines = text.split('\n');
    const elements: React.ReactNode[] = [];
    
    let listItems: React.ReactNode[] = [];
    let inList = false;

    // Helper to close an open list
    const flushList = (key: number) => {
      if (inList && listItems.length > 0) {
        elements.push(
          <ul key={`list-${key}`} className="list-disc pl-6 mb-4 space-y-2 marker:text-indigo-400">
            {[...listItems]}
          </ul>
        );
        listItems = [];
        inList = false;
      }
    };

    // Helper to handle bold formatting **text**
    const parseInline = (text: string) => {
      const parts = text.split(/(\*\*.*?\*\*)/g);
      return parts.map((part, i) => {
        if (part.startsWith('**') && part.endsWith('**')) {
          return <strong key={i} className="font-bold text-indigo-950 bg-indigo-50/50 rounded px-0.5">{part.slice(2, -2)}</strong>;
        }
        return part;
      });
    };

    lines.forEach((line, index) => {
      const trimmed = line.trim();

      // Skip generic empty lines if not breaking paragraphs significantly
      if (!trimmed && !inList) return; 

      // Headers
      if (line.startsWith('### ')) {
        flushList(index);
        elements.push(<h3 key={index} className="text-xl font-bold text-slate-700 mt-6 mb-3 border-b-2 border-transparent hover:border-indigo-100 transition-colors inline-block">{line.replace('### ', '')}</h3>);
      } else if (line.startsWith('## ')) {
        flushList(index);
        elements.push(<h2 key={index} className="text-2xl font-bold text-indigo-900 mt-10 mb-5">{line.replace('## ', '')}</h2>);
      } else if (line.startsWith('# ')) {
        flushList(index);
        elements.push(<h1 key={index} className="text-3xl font-extrabold text-slate-900 mt-12 mb-6 border-b pb-4">{line.replace('# ', '')}</h1>);
      } 
      // Lists (Bullet points)
      else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
        inList = true;
        const content = trimmed.substring(2);
        listItems.push(<li key={`li-${index}`} className="pl-1 text-slate-700 leading-relaxed">{parseInline(content)}</li>);
      }
      // Blockquotes
      else if (trimmed.startsWith('> ')) {
        flushList(index);
        elements.push(
          <blockquote key={index} className="border-l-4 border-indigo-500 pl-4 italic bg-slate-50 py-3 pr-4 my-6 rounded-r text-slate-600 shadow-sm">
            {parseInline(trimmed.substring(2))}
          </blockquote>
        );
      }
      // Paragraphs
      else if (trimmed !== '') {
        flushList(index);
        elements.push(<p key={index} className="mb-4 text-justify leading-7 text-slate-800">{parseInline(trimmed)}</p>);
      }
      // Handle whitespace breaks manually if needed, or just let margins handle it
      else {
        flushList(index);
      }
    });
    
    // Flush any remaining list at the end
    flushList(lines.length);

    return elements;
  };

  return (
    <div className="prose prose-lg prose-slate max-w-none font-serif">
      {renderContent(content)}
    </div>
  );
};
